# This file is a mess, but does the job
import sys
sys.dont_write_bytecode = True

import config
import chip
import re

def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else text.lower()
            for text in re.split(_nsre, s)] 

peripheral_counters = {}
peripheral_source_code_cache = {}

def get_cached_code_include(mcu, periph, source_code):
    series = mcu.mcu_name[5:7]
    key = series + source_code
    
    if key in peripheral_source_code_cache:
        return peripheral_source_code_cache[key]
    
    counter_key = series + periph
    peripheral_counters.setdefault(counter_key, 1)
    
    counter = peripheral_counters[counter_key]
    peripheral_counters[counter_key] = peripheral_counters[counter_key] + 1
    
    filename = "stm32_" + periph + '_variant_' + str(counter) + '.h'
    
    peripheral_source_code_cache[key] = filename
    
    with open(config.system_dir + 'STM32' + series + '/stm32_chip/' + filename, "w") as f:
        f.write(source_code)
        
    return filename


def generate_source_code(mcu):
    source_code = '';
    source_code = '//Autogenerated file\n'
    source_code += '//MCU name: ' + mcu.mcu_name+ '\n'
    source_code += '//MCU  xml: ' + mcu.mcu_xml_filename+ '\n'
    source_code += '//GPIO remap/alternate function xml: ' + mcu.remap_xml_filename+ '\n'
    
    source_code += '\n'
    
    gpio_pins = [pin for pin in mcu.pins if pin.startswith('P') and pin != 'PDR_ON']
    
    source_code += '\n'
    gpio_source_code = '// If you want to change the default pin order\n'
    gpio_source_code = 'copy the pin list from below to the variant.h file\n'
    gpio_source_code = '\n'
    gpio_source_code += '#define VARIANT_PIN_LIST_DEFAULT \\\n'
    
    mcu.default_pin_list = '#define CHIP_PIN_LIST';
    for pin in sorted(gpio_pins, key=lambda x: (x[0:2], int(x[2:]))):
         gpio_source_code += '   PIN(' + pin[1] + ',' + pin[2:] + '), \\\n'
         mcu.default_pin_list += ' PIN(' + pin[1] + ',' + pin[2:] + '),'
    mcu.default_pin_list += '\n'
    
    gpio_source_code += '\n'
    
    include = get_cached_code_include(mcu, 'GPIO', gpio_source_code)
    source_code += '#include "' + include + '"\n'
    source_code += '\n'
    
    include_source_code = ''
    
    for periph in sorted(mcu.peripheral_to_signals):
        periph_source_code = "";
        if periph == 'UART':
            continue
        
        if 'SDIO' in periph:
            periph_source_code += '#define STM32_CHIP_HAS_SDIO'
            periph_source_code += '\n'
        if 'I2S' in periph:
            periph_source_code += '#define STM32_CHIP_HAS_I2S'
            periph_source_code += '\n'
    
        if periph == 'TIM':
            old = False
            
            all_timers_source_code = ''
            
            for i in range(1, 19): 
                instance = 'TIM' + str(i)
                 
                periph_source_code += '\n' 
                periph_source_code += 'const stm32_tim_pin_list_type chip_' + instance.lower() + ' [] = {\n' 
                     
                for periph_signal in sorted(set(mcu.peripheral_signal_to_instance_signals)): 
                         
                    for signal in sorted(set(mcu.peripheral_signal_to_instance_signals[periph_signal])): 
                         
                        for pin in sorted(set(mcu.instance_signal_to_pin_to_af[signal]), key = natural_sort_key): 
                             
                            p = signal.split('_')[0] 
                            sig = signal.split('_')[1] 
                             
                            if p != instance: 
                                continue 
                                 
                            if sig not in ('BKIN', 'BKIN2', 'CH1', 'CH1N', 'CH2', 'CH2N', 'CH3', 'CH3N', 'CH4', 'CH4N', 'ETR'): 
                                continue 
                     
                            if pin in mcu.pins: 
                                remap = mcu.instance_signal_to_pin_to_af[signal][pin] 
                                mcu.af_function_used.append(remap) 
                                 
                                split = signal.split('_') 
                                p = split[0] 
                                 
                                p = p.replace('I2S', 'SPI'); 
                     
                                timer_line = '    { ' + p.ljust(6) + ',GPIO' + pin[1:2] + ', GPIO_PIN_' + pin[2:].ljust(3) + ',TIM_' + sig.ljust(7) + ', ' + remap.ljust(15) + '}, \n'
                     
                                periph_source_code += timer_line
                                
                                all_timers_source_code += timer_line
                 
                periph_source_code += '}; \n' 
            
            periph_source_code += '\n' 
            periph_source_code += 'const stm32_tim_pin_list_type chip_tim [] = {\n' 
            periph_source_code += all_timers_source_code
            periph_source_code += '}; \n' 
                
        for sig in sorted(set(mcu.peripheral_to_signals[periph])):
        
            if 'SDIO' not in periph and 'I2S' not in periph and sig not in ['SDA', 'SCL', 'TX', 'RX', 'MISO', 'MOSI', 'SCK', 'NSS']:
                continue
                
            if 'I2S' == periph and sig == 'CKIN':
                continue
                
            if 'CAN' == periph:
                continue
                
            periph_source_code += '\n'
            periph_source_code += 'const stm32_af_pin_list_type chip_af_'+(periph + '_' + sig).lower()+' [] = {\n'
            #print mcu.group_signals
            old = False
            
            signals = mcu.peripheral_signal_to_instance_signals[periph + '_' +sig]
            if periph == 'USART' and 'UART' in mcu.peripheral_to_signals:
                signals.extend(mcu.peripheral_signal_to_instance_signals['UART_' +sig])
            
            for signal in sorted(set(signals)):
                if old != signal.split('_')[0]:
                    periph_source_code += '//' + signal.split('_')[0] + '\n'
                p = signal.split('_')[0]
                for pin in sorted(set(mcu.instance_signal_to_pin_to_af[signal]), key = natural_sort_key):
                    if pin in mcu.pins:
                        remap = mcu.instance_signal_to_pin_to_af[signal][pin]
                        mcu.af_function_used.append(remap)
                        
                        split = signal.split('_')
                        p = split[0]
                        
                        p = p.replace('I2S', 'SPI');
            
                        periph_source_code += '    { ' + p.ljust(6) + ', GPIO' + pin[1:2] + ', GPIO_PIN_' + pin[2:].ljust(3) + ', ' + remap.ljust(15) + '}, \n'
                
            periph_source_code += '}; \n'
        
        if periph_source_code:
            include = get_cached_code_include(mcu, periph, periph_source_code)
            include_source_code += '#include "' + include + '"\n'
            include_source_code += '\n'
        
    remap_source_code = ''
    
    if len(mcu.af_functions) > 0:
        remap_source_code += 'static void AF_NO_REMAP (void) { }\n'
        
    for af_function in mcu.af_functions:
        if af_function in mcu.af_function_used:
            remap_source_code += '#ifdef ' + af_function[2:] + '\n'
            remap_source_code += 'static void ' + af_function + '(void) { ' + af_function[2:] + '(); }\n'
            remap_source_code += '#else\n'
            remap_source_code += 'static void ' + af_function + '(void) { AF_NO_REMAP(); }\n'
            remap_source_code += '#endif\n'
            remap_source_code += '\n'
    
    include = get_cached_code_include(mcu, 'REMAP', remap_source_code)
    source_code += '#include "' + include + '"\n'
    source_code += '\n'
    
    source_code += include_source_code
    
    adc_source_code = 'const stm32_chip_adc1_channel_type chip_adc1_channel[] = {\n'
    
    for instance_signal in sorted(mcu.instance_signal_to_default_pin.keys(), key = natural_sort_key):
        if 'ADC' not in instance_signal or '_IN' not in instance_signal:
            continue
            
        (instance, channel) = instance_signal.split('_', 1)
        if not channel[2:].isdigit():
            continue
        if instance == 'ADC':
            instance = 'ADC1'
            
        pin = mcu.instance_signal_to_default_pin[instance_signal]
        adc_source_code += '    { ' + instance + ', GPIO' + pin[1:2] + ', GPIO_PIN_' + pin[2:].ljust(3) + ', ADC_CHANNEL_' + channel[2:].ljust(3) + '}, \n'
    
    adc_source_code += '};\n'
    
    include = get_cached_code_include(mcu, 'ADC', adc_source_code)
    source_code += '#include "' + include + '"\n'
    source_code += '\n'
    
    
    clock_source_code = 'const stm32_clock_freq_list_type chip_clock_freq_list[] = {\n'
    for periph in sorted(mcu.PCLK1_PERIPHERALS):
        if not periph.startswith('USART') and not periph.startswith('SPI') and not periph.startswith('I2C'):
            continue
        
        if periph not in mcu.instances:
            continue
        
        clock_source_code += '    {' + periph.ljust(6) + ', HAL_RCC_GetPCLK1Freq },  \n'
    
    clock_source_code += '\n'
    
    for periph in sorted(mcu.PCLK2_PERIPHERALS):
        if not periph.startswith('USART') and not periph.startswith('SPI') and not periph.startswith('I2C'):
            continue
        
        if periph not in mcu.instances:
            continue
            
        clock_source_code += '    {' + periph.ljust(6) + ', HAL_RCC_GetPCLK2Freq },  \n'
    
    clock_source_code += '};\n'
    
    include = get_cached_code_include(mcu, 'FREQ', clock_source_code)
    source_code += '#include "' + include + '"\n'
    
    source_code += '\n'
    
    dir = config.system_dir + name[:7] + "/stm32_chip/"
    with open(dir + 'stm32_' + mcu.mcu_name + '.h', 'w') as file:
        file.write(source_code)
    

with open(config.stm32_dir + 'stm32_build_defines.h', 'w') as file:
    file.write('//Autogenerated file\n')
    file.write('\n')
    file.write('#ifndef STM32_BUILD_DEFINES_H\n')
    file.write('#define STM32_BUILD_DEFINES_H\n')
    file.write('\n')
    
    name_processed = []
    
    file.write('#if __IGNORE\n')
        
    for mcu in chip.mcus:
        name = mcu.attrib['RefName'] 
        name = name[:11]
        
        if name in name_processed:
            continue
        
        print name
            
        name_processed.append(name)
        
        dir = config.system_dir + name[:7] + "/CMSIS_Inc/"
        #filename = name.lower()
        define = chip.get_productline_for_include(name)
        if not define:
            continue
        
        file.write('\n');
        file.write('#elif defined(' + name + ')\n')
        file.write('  #define ' + define + ' 1\n')
        file.write('  #define CMSIS_STARTUP_ASSEMBLY "startup_' + define.lower() + '.s"\n')
        file.write('  #define CHIP_PERIPHERAL_INCLUDE "stm32_' + name + '.h"\n')
        
        mcu = chip.load_mcu(name)
        generate_source_code(mcu)
        
        file.write('  ' + mcu.default_pin_list)
        
    file.write('#else \n')
    file.write('#error UNKNOWN CHIP \n')
    file.write('#endif\n')
    
    file.write('\n')
    file.write('#endif')

    
    
